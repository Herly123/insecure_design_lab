cd ~/insecure_design_lab

mkdir -p code/secure

cat > code/secure/db_lockout.py <<'PY'
# code/secure/db_lockout.py
# Persistencia simple de bloqueos e intentos fallidos usando SQLite3.

import sqlite3
from pathlib import Path

DB_PATH = Path(__file__).resolve().parent / "lockout.db"

def get_connection():
    conn = sqlite3.connect(DB_PATH)
    conn.execute("""
        CREATE TABLE IF NOT EXISTS locks (
            username TEXT PRIMARY KEY,
            failed_count INTEGER DEFAULT 0,
            lock_until REAL DEFAULT 0
        )
    """)
    conn.commit()
    return conn

def get_status(username):
    conn = get_connection()
    cur = conn.cursor()
    cur.execute("SELECT failed_count, lock_until FROM locks WHERE username=?", (username,))
    row = cur.fetchone()
    conn.close()
    return row if row else (0, 0)

def update_status(username, failed_count, lock_until):
    conn = get_connection()
    conn.execute("""
        INSERT INTO locks (username, failed_count, lock_until)
        VALUES (?, ?, ?)
        ON CONFLICT(username) DO UPDATE SET
            failed_count=excluded.failed_count,
            lock_until=excluded.lock_until
    """, (username, failed_count, lock_until))
    conn.commit()
    conn.close()

def reset_user(username):
    conn = get_connection()
    conn.execute("DELETE FROM locks WHERE username=?", (username,))
    conn.commit()
    conn.close()

def clear_all():
    conn = get_connection()
    conn.execute("DELETE FROM locks")
    conn.commit()
    conn.close()
PY
