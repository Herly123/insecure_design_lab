# code/secure/app.py
# Auth seguro con PBKDF2 + salt, bloqueo por intentos y persistencia opcional via code.secure.db_lockout
# Esta versión intenta importar db_lockout por paquete y, si falla, lo carga por ruta.

import hashlib
import hmac
import secrets
import time
import logging
from logging.handlers import RotatingFileHandler
from pathlib import Path
from typing import Dict

# ==========================================================
# CONFIGURACIÓN BASE
# ==========================================================
ITERATIONS = 200_000
MAX_FAILED = 3
LOCKOUT_SECONDS = 10

# ==========================================================
# LOGGING CONFIGURACIÓN
# ==========================================================
PROJECT_ROOT = Path(__file__).resolve().parents[2]
LOG_DIR = PROJECT_ROOT / "logs"
LOG_DIR.mkdir(parents=True, exist_ok=True)

LOG_FILE = LOG_DIR / "auth.log"
LOG_MAX_BYTES = 5 * 1024 * 1024
LOG_BACKUPS = 3

logger = logging.getLogger("secure_auth")
# Evitar duplicar handlers si el módulo se importa varias veces
if not logger.handlers:
    handler = RotatingFileHandler(LOG_FILE, maxBytes=LOG_MAX_BYTES, backupCount=LOG_BACKUPS)
    formatter = logging.Formatter("%(asctime)s %(levelname)s %(message)s")
    handler.setFormatter(formatter)
    logger.addHandler(handler)
    logger.setLevel(logging.INFO)

# ==========================================================
# INTENTAR USAR DB PARA LOCKOUT (forma robusta: paquete -> ruta)
# ==========================================================
_USE_DB = False
db_lockout = None
_import_errors = []

# intento 1: import por paquete (requiere code/__init__.py y code/secure/__init__.py)
try:
    from code.secure import db_lockout  # type: ignore
    _USE_DB = True
    logger.info("db_lockout: habilitado via paquete")
except Exception as e:
    _import_errors.append(("package_import", e))

# intento 2: cargar por ruta absoluta relativa al archivo
if not _USE_DB:
    try:
        import importlib.util
        db_path = Path(__file__).resolve().parent / "db_lockout.py"
        if db_path.exists():
            spec = importlib.util.spec_from_file_location("code_secure_db_lockout", str(db_path))
            module = importlib.util.module_from_spec(spec)
            spec.loader.exec_module(module)
            db_lockout = module
            _USE_DB = True
            logger.info("db_lockout: habilitado via carga por ruta (%s)", db_path)
    except Exception as e:
        _import_errors.append(("path_import", e))

if not _USE_DB:
    db_lockout = None
    logger.info("db_lockout: no disponible (usando lockout en memoria)")
    for tag, err in _import_errors:
        logger.debug("db_lockout import error (%s): %s", tag, err, exc_info=True)

# ==========================================================
# USUARIOS CON HASH Y SALT (almacenamiento en memoria para demo)
# ==========================================================
def _hash_password(password: str, salt: bytes) -> bytes:
    return hashlib.pbkdf2_hmac("sha256", password.encode(), salt, ITERATIONS)

_users: Dict[str, Dict[str, bytes]] = {}
# crear admin y user con salts
_admin_salt = secrets.token_bytes(16)
_users["admin"] = {"salt": _admin_salt, "hash": _hash_password("123456", _admin_salt)}
_user_salt = secrets.token_bytes(16)
_users["user"] = {"salt": _user_salt, "hash": _hash_password("password", _user_salt)}

# ==========================================================
# FALLBACK: RATE LIMITING EN MEMORIA (si no hay DB)
# ==========================================================
_failed_attempts: Dict[str, int] = {}
_lockout_until: Dict[str, float] = {}

# ==========================================================
# HELPERS para persistencia o memoria (abstract)
# ==========================================================
def _get_status(username: str):
    """
    Devuelve (failed_count:int, lock_until:float)
    Usa DB si está disponible, sino la estructura en memoria.
    """
    if _USE_DB and db_lockout:
        try:
            return db_lockout.get_status(username)
        except Exception:
            logger.exception("Error leyendo db_lockout.get_status; usando memoria")
    # memoria
    return _failed_attempts.get(username, 0), _lockout_until.get(username, 0.0)

def _update_status(username: str, failed_count: int, lock_until: float):
    if _USE_DB and db_lockout:
        try:
            db_lockout.update_status(username, failed_count, lock_until)
            return
        except Exception:
            logger.exception("Error actualizando db_lockout.update_status; usando memoria")
    _failed_attempts[username] = failed_count
    if lock_until:
        _lockout_until[username] = lock_until
    else:
        _lockout_until.pop(username, None)

def _reset_user(username: str):
    if _USE_DB and db_lockout:
        try:
            db_lockout.reset_user(username)
            return
        except Exception:
            logger.exception("Error reseteando usuario en db_lockout; usando memoria")
    _failed_attempts.pop(username, None)
    _lockout_until.pop(username, None)

# ==========================================================
# LÓGICA DE LOCK / LOGIN
# ==========================================================
def login(username: str, password: str) -> bool:
    now = time.time()

    failed_count, lock_until = _get_status(username)
    # si está bloqueado en la fuente (DB o memoria)
    if lock_until and now < lock_until:
        logger.info("Rechazado login para '%s': cuenta bloqueada hasta %s", username, lock_until)
        return False

    # verificar existencia
    if username not in _users:
        # contar fallo y persistir
        failed_count += 1
        logger.warning("Intento fallido para usuario no existente '%s'", username)
        if failed_count >= MAX_FAILED:
            new_lock_until = time.time() + LOCKOUT_SECONDS
            _update_status(username, 0, new_lock_until)
            logger.warning("Usuario '%s' bloqueado hasta %s (epoch)", username, new_lock_until)
        else:
            _update_status(username, failed_count, 0.0)
        return False

    # existe usuario
    user = _users[username]
    hashed = _hash_password(password, user["salt"])
    ok = hmac.compare_digest(hashed, user["hash"])

    if ok:
        logger.info("Login exitoso para '%s'", username)
        _reset_user(username)
        return True
    else:
        # fallo: incrementar y aplicar bloqueo si corresponde
        failed_count += 1
        logger.warning("Intento fallido para usuario '%s' (contador=%d)", username, failed_count)
        if failed_count >= MAX_FAILED:
            new_lock_until = time.time() + LOCKOUT_SECONDS
            _update_status(username, 0, new_lock_until)
            logger.warning("Usuario '%s' bloqueado hasta %s (epoch)", username, new_lock_until)
        else:
            _update_status(username, failed_count, 0.0)
        logger.info("Login fallido para '%s': contraseña incorrecta", username)
        return False

# ==========================================================
# Utilidades para tests / demos
# ==========================================================
def get_users():
    """Devuelve copia de usuarios (hashes)."""
    return {k: {"salt": v["salt"], "hash": v["hash"]} for k, v in _users.items()}

def _set_lock_params(max_failed: int = 3, lockout_seconds: int = 10):
    global MAX_FAILED, LOCKOUT_SECONDS
    MAX_FAILED = max_failed
    LOCKOUT_SECONDS = lockout_seconds
    logger.info("[DEMO] Parámetros de lockout ajustados: MAX_FAILED=%d, LOCKOUT_SECONDS=%d", max_failed, lockout_seconds)

# ==========================================================
# CLI simple para pruebas manuales
# ==========================================================
if __name__ == "__main__":
    print("=== Login seguro (con persistencia opcional) ===")
    try:
        user = input("Usuario: ").strip()
        pwd = input("Contraseña: ")
        ok = login(user, pwd)
        print("✅ Acceso concedido" if ok else "❌ Acceso denegado")
    except KeyboardInterrupt:
        print("\nCancelado por el usuario.")
