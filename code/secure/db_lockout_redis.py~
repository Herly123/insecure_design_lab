# code/secure/db_lockout_redis.py
"""
Backend de lockout usando Redis.
Funciones:
- is_blocked(username) -> (blocked: bool, ttl_remaining_seconds: int)
- record_failed_attempt(username) -> dict with keys: blocked(bool), attempts(int), ttl(int)
- reset_attempts(username)
- get_attempts(username) -> int
Configurable via REDIS_URL, MAX_FAILED, LOCKOUT_SECONDS, WINDOW_SECONDS
"""

import os
import time
from typing import Tuple, Dict

try:
    import redis
except Exception as e:
    raise RuntimeError("redis library is required for db_lockout_redis.py") from e

REDIS_URL = os.environ.get("REDIS_URL", "redis://redis:6379/0")
MAX_FAILED = int(os.environ.get("MAX_FAILED", "3"))
LOCKOUT_SECONDS = int(os.environ.get("LOCKOUT_SECONDS", "60"))
WINDOW_SECONDS = int(os.environ.get("WINDOW_SECONDS", "300"))

# Keys
def _attempts_key(username: str) -> str:
    return f"login:attempts:{username}"

def _blocked_key(username: str) -> str:
    return f"login:blocked:{username}"

# Redis client
_r = redis.from_url(REDIS_URL, decode_responses=True)

def is_blocked(username: str) -> Tuple[bool, int]:
    """
    Return (blocked, ttl_seconds)
    """
    key = _blocked_key(username)
    ttl = _r.ttl(key)
    if ttl is None:
        # Key does not exist -> not blocked
        return False, 0
    if ttl < 0:
        # Some redis versions: -1 means key exists without ttl -> treat as blocked with unknown ttl
        return True, 0
    return (ttl > 0), int(ttl)

def get_attempts(username: str) -> int:
    """
    Return number of attempts recorded in the active window.
    """
    val = _r.get(_attempts_key(username))
    try:
        return int(val) if val is not None else 0
    except Exception:
        return 0

def reset_attempts(username: str) -> None:
    """
    Delete attempts counter (on successful login).
    """
    _r.delete(_attempts_key(username))

def record_failed_attempt(username: str) -> Dict:
    """
    Atomically increment attempts, set window TTL, and if threshold reached,
    set blocked key with LOCKOUT_SECONDS expiration.
    Returns a dict:
      {"blocked": bool, "attempts": int, "ttl": int}
    """
    akey = _attempts_key(username)
    bkey = _blocked_key(username)

    # If already blocked, return early with remaining ttl
    blocked, ttl = is_blocked(username)
    if blocked:
        return {"blocked": True, "attempts": get_attempts(username), "ttl": ttl}

    # INCR attempts atomically
    attempts = _r.incr(akey)
    # Ensure window TTL is set (only when first created)
    if attempts == 1:
        _r.expire(akey, WINDOW_SECONDS)

    if attempts >= MAX_FAILED:
        # Set blocked key with TTL and remove attempts counter
        _r.set(bkey, "1", ex=LOCKOUT_SECONDS)
        _r.delete(akey)
        return {"blocked": True, "attempts": attempts, "ttl": LOCKOUT_SECONDS}
    else:
        return {"blocked": False, "attempts": attempts, "ttl": _r.ttl(akey) or 0}
